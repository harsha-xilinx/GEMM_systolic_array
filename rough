‚úÖ Stretch Ideas (Choose any 1‚Äì2)

‚úÖ Add FP16 datapath
‚úÖ Support Winograd / convolution mode
‚úÖ Support sparse matrices
‚úÖ Add RISC-V integration via AXI-Lite
‚úÖ Produce a small compiler/driver (Python)

Pick based on interest.

‚úÖ Expected Resume Line

Designed a configurable N√óN systolic-array matrix-multiplication accelerator in SystemVerilog; verified using cocotb + numpy golden models; implemented AXI-stream interface; synthesized using OpenLane (Sky130) achieving X MHz and Y mm¬≤; measured throughput improvement of 15√ó vs software GEMM.
‚úÖ 3) Published Designs (optional)

You can briefly compare to specs of:

NVIDIA Tensor Core

Google TPU v1 systolic core

Qualcomm Hexagon

No FPGA needed ‚Äî just conceptual comparisons.

6. Memory + Interfaces
6.1 Input Buffers

May hold tiles of A and B.

(Initial version can use streams or preloaded arrays.)

6.2 Output Buffer

Collects C after complete execution.

6.3 AXI Option (Stretch Goal)

AXI4-Lite ‚Üí control

AXI4-Stream ‚Üí high-speed data


               +-----------------------------+
 A_stream ---> |      Input Buffer / DMA     |
               +-----------------------------+
                          |
                          v
                    +-----------+
                   | Controller |
                    +-----------+
                          |
                          v
     B_stream ---> +------------------+
                   | Systolic Array   |
                   |   (N x N PEs)    |
                   +------------------+
                          |
                          v
                  +-------------------+
                  | Output Collector  |
                  +-------------------+
                          |
                          v
                     C_stream / AXI


‚úÖ More detail

A systolic array is just a grid of PEs with structured data movement ‚Äî
it does not inherently force weight-stationary.

There are 3 common dataflows:
| Dataflow              | What stays in PE? | Good for     |
| --------------------- | ----------------- | ------------ |
| **Weight-stationary** | B (weights)       | Inference    |
| **Output-stationary** | C / accumulators  | GEMM general |
| **Input-stationary**  | A (activations)   | Some conv/FC |
| **(Hybrid)**          | Combinations      | TPU-style    |

‚úÖ Project plan clarification

‚û°Ô∏è For the first version of this project:
We will implement output-stationary, because it‚Äôs the simplest:

Accumulator stays in PE

A & B both stream

I suggested weight-stationary as an optional second mode, but to avoid confusion:

‚úÖ We will build output-stationary first, not weight-stationary.
Why?

Output-stationary is the standard intro GEMM systolic array

Easier to understand + verify

Many open-source examples follow this

Avoids storing B in PE
So:
‚úÖ First: Output-stationary
Optional later: Add weight-stationary mode

‚úÖ Final clarification
| Concept           | Meaning                               |
| ----------------- | ------------------------------------- |
| Systolic array    | Structured data movement grid         |
| Stationary type   | How data is stored/reused             |
| Weight-stationary | Store B inside PE                     |
| Output-stationary | Store C accumulator in PE             |
| This project      | Start with output-stationary (simple) |

7 ‚Äî RTL module list & responsibilities
rtl/
  pe.sv                // single PE
  systolic_array.sv    // instantiates N x N PEs and wires them
  controller.sv        // sequences inputs, tiling, counters
  input_buffer.sv      // optional: FIFOs/stream adapters
  output_collector.sv  // collects acc_out from boundary PEs and packages C
  top.sv               // top-level wrapper (parameters + test hooks)
sim/
  tb_top.sv            // small SV TB (if using pure SV)
cocotb/
  test_gemm.py         // cocotb tests: random matrices, edge cases, perf counters
scripts/
  gen_matrices.py
  run_verilator.sh
docs/
  arch_doc.md

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sorry, my query is in a 4x4 systolic array, in single clock, we will feed 4 data of Matrix A and 4 data of Matrix B. right ?
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Yes ‚Äî for a 4√ó4 systolic array, that is correct. ‚úÖ

Here‚Äôs the reasoning:
‚úÖ Feeding a 4√ó4 systolic array per clock cycle

The array has 4 rows √ó 4 columns ‚Üí 16 PEs.

Each PE needs one A and one B value per cycle to perform its MAC.

In output-stationary dataflow:

A flows horizontally (left ‚Üí right)

B flows vertically (top ‚Üí bottom)

Per clock cycle:

Feed 4 A values into the left edge, one per row

Feed 4 B values into the top edge, one per column

This ensures all 4√ó4 PEs get the correct A and B values in the right diagonal pattern.

Total: 8 values per cycle

Each PE computes acc += A*B for that cycle
‚ö† Important Notes

You do not feed an entire row or column of the matrix at once ‚Äî only one element per row/column per cycle.

It takes 4 cycles to feed an entire 4√ó4 tile of A and 4√ó4 tile of B completely into the array.

After feeding, the array enters the drain phase to flush out remaining computations.

If you want, I can make a cycle-by-cycle diagram for the 4√ó4 array showing exactly which A and B elements go into which PE each cycle ‚Äî it‚Äôs very helpful for visualizing fill/compute/drain.

Perfect! Let‚Äôs make a cycle-by-cycle diagram for a 4√ó4 output-stationary systolic array showing how A and B elements flow through the array. This will clearly illustrate the fill ‚Üí compute ‚Üí drain phases.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Cycle-by-Cycle Table

Let A[i][j] be elements of matrix A (4√ó4), B[i][j] for matrix B.
| Cycle | Left-edge A inputs             | Top-edge B inputs              | PE computation (row,col) notes                                                     |
| ----- | ------------------------------ | ------------------------------ | ---------------------------------------------------------------------------------- |
| 0     | A[0,0], A[1,0], A[2,0], A[3,0] | B[0,0], B[0,1], B[0,2], B[0,3] | PEs on diagonal start computing: PE[0,0]=A[0,0]*B[0,0], others start receiving A/B |
| 1     | A[0,1], A[1,1], A[2,1], A[3,1] | B[1,0], B[1,1], B[1,2], B[1,3] | Previous A/B shift right/down: PEs update acc with new A*B                         |
| 2     | A[0,2], A[1,2], A[2,2], A[3,2] | B[2,0], B[2,1], B[2,2], B[2,3] | PEs continue MACs; diagonal moves further into array                               |
| 3     | A[0,3], A[1,3], A[2,3], A[3,3] | B[3,0], B[3,1], B[3,2], B[3,3] | Last cycle of **fill phase**; bottom-right PE starts final accumulation            |
| 4     | ‚Äî                              | ‚Äî                              | **Drain phase begins**: remaining products propagate through PEs                   |
| 5     | ‚Äî                              | ‚Äî                              | Drain continues; all PEs accumulate pending values                                 |
| 6     | ‚Äî                              | ‚Äî                              | Drain continues; bottom-right PE ready to output final result                      |
| 7     | ‚Äî                              | ‚Äî                              | Final outputs available from all PEs                                               |

                                       ASCII Diagram Example (Cycle 0)
                                       Cycle 0:

A inputs ‚Üí          PE matrix:
A[0,0] ‚Üí PE[0,0]  
A[1,0] ‚Üí PE[1,0]  
A[2,0] ‚Üí PE[2,0]  
A[3,0] ‚Üí PE[3,0]  

B inputs ‚Üì
B[0,0] ‚Üí PE[0,0]
B[0,1] ‚Üí PE[0,1]
B[0,2] ‚Üí PE[0,2]
B[0,3] ‚Üí PE[0,3]

PE computations:
PE[0,0] += A[0,0]*B[0,0]
PE[0,1] += A[0,?]*B[0,1]  (waiting for A to propagate)
PE[1,0] += A[1,0]*B[?,0]  (waiting for B to propagate)
...

Each subsequent cycle shifts A right and B down.

After 4 cycles, the array is fully filled and MAC operations continue.

The last 3‚Äì4 cycles are for draining the outputs from the array.

Key Notes

Fill Phase: Cycles 0‚Äì3 (injecting all tile data)

Compute Phase: Diagonal MACs happen simultaneously

Drain Phase: Cycles 4‚Äì7 (final accumulated results exit array)

One element per PE per cycle: The array never receives a full column/row of matrix in a single clock

Diagonal wave: The MAC ‚Äúwave‚Äù moves from top-left to bottom-right
üìå Summary

4√ó4 array ‚Üí feed 4 A + 4 B per cycle

Fill takes 4 cycles

Drain takes additional cycles (equal to array size minus 1)

Total cycles for 4√ó4 tile = 8 cycles for output-stationary flow
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
So, a controller will be there before PE and it will give 4 inputs for A and 4 inputs B. right ?
Yes ‚Äî exactly! ‚úÖ

Let me clarify carefully for a 4√ó4 output-stationary systolic array:
‚úÖ Summary:

Yes, controller feeds 4 A + 4 B values per cycle to the 4√ó4 array.

Controller also handles valid, clear_acc, and sample_acc signals.

This is exactly what you need for an output-stationary systolic array.

‚úÖ How the Controller Feeds A
Key Rules:

One cycle = one element per PE row

Array has 4 rows ‚Üí controller sends 4 A elements per cycle

Each element goes to the leftmost PE of that row

**Elements come from the current column of the matrix A tile

Matrix A (4√ó4):
A = | A00 A01 A02 A03 |
    | A10 A11 A12 A13 |
    | A20 A21 A22 A23 |
    | A30 A31 A32 A33 |

Cycle 0

Controller feeds first column of A (column 0):

A_out[0] = A00 ‚Üí PE[0,0]
A_out[1] = A10 ‚Üí PE[1,0]
A_out[2] = A20 ‚Üí PE[2,0]
A_out[3] = A30 ‚Üí PE[3,0]

Cycle 1

Controller feeds second column of A (column 1):

A_out[0] = A01 ‚Üí PE[0,0] (moves right next cycle)
A_out[1] = A11 ‚Üí PE[1,0]
A_out[2] = A21 ‚Üí PE[2,0]
A_out[3] = A31 ‚Üí PE[3,0]


‚úÖ Notice: it‚Äôs the next column, not the entire row.

So Cycle 1 output from controller for A is: A01, A11, A21, A31

Not A00‚ÄìA03 (which is the first row)

‚úÖ Pattern Summary
Cycle	A_out[0:3]
0	A00, A10, A20, A30
1	A01, A11, A21, A31
2	A02, A12, A22, A32
3	A03, A13, A23, A33

Controller feeds one column of A per cycle, one element per PE row.

After 4 cycles, the full 4√ó4 tile has been injected.

B Elements (for reference)

Top edge, one element per column, similar logic: feed row of B per cycle.

üí° Important:

Each PE receives one new A and one new B per cycle

Accumulators in PEs keep summing (output-stationary)
            
                           
                           
